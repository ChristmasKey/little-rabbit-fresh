# 小兔鲜电商项目笔记



## 项目技术栈

Vue3全家桶

- Vite：前端构建工具
- create-vue：新一代Vue脚手架
- Pinia：状态管理工具（代替vuex）
- ElementPlus：前端UI框架
- Vue3+Setup：前端技术框架（Setup语法糖）
- Vue-Router：路由管理工具
- VueUse：Vue的组合工具集（涵盖了很多常用的工具类方法）



## 项目规模&亮点

![项目规模](./images/项目规模.png)

亮点：

![项目亮点](./images/项目亮点.png)



## 认识create-vue

create-vue是Vue<span style="color:red;">官方新的脚手架工具</span>，底层切换到了<span style="color:red;">vite（下一代前端工具链）</span>，为开发提供极速响应

![vue-cli和create-vue](./images/vue-cli和create-vue.png)

### 使用create-vue创建项目

==1.前提环境条件==：<span style="color:red;">已经安装16.0或更高版本的 Node.js</span>



2.创建一个Vue应用：`npm init vue@latest`，这一指令将会安装并执行create-vue

![利用create-vue创建项目](./images/利用create-vue创建项目.png)

3.熟悉项目目录和关键文件

**package.json** 中存放了项目的相关命令和核心依赖，<span style="color:red;">核心依赖项变成了Vue3.x 和 vite</span>

**vite.config.js** 替代了vue.config.js，作为项目配置文件，<span style="color:red;">是基于vite的配置</span>

**src/main.js** 项目的入口文件，<span style="color:red;">采用了createApp函数创建应用实例</span>

**app.vue** 根组件，<span style="color:red;">SFC单文件组件 script-template-style</span>

- 变化一：脚本script和模板template顺序调整
- 变化二：模板template不再要求唯一根元素
- 变化三：脚本script添加setup标识，支持组合式API

```vue
<!--setup：一个开关，表示允许在script标签中直接书写组合式API-->
<script setup>
import HelloWorld from './components/HelloWorld.vue'
import TheWelcome from './components/TheWelcome.vue'
</script>

<template>
  <!--不再要求唯一根元素-->
  <header>
    <img alt="Vue logo" class="logo" src="./assets/logo.svg" width="125" height="125" />

    <div class="wrapper">
      <HelloWorld msg="You did it!" />
    </div>
  </header>

  <main>
    <TheWelcome />
  </main>
</template>

<style scoped>
header {
  line-height: 1.5;
}

.logo {
  display: block;
  margin: 0 auto 2rem;
}

@media (min-width: 1024px) {
  header {
    display: flex;
    place-items: center;
    padding-right: calc(var(--section-gap) / 2);
  }

  .logo {
    margin: 0 2rem 0 0;
  }

  header .wrapper {
    display: flex;
    place-items: flex-start;
    flex-wrap: wrap;
  }
}
</style>
```



**index.html**：单页入口，<span style="color:red;">提供id为app的挂载点</span>

![项目目录结构](./images/项目目录结构.png)



## 组合式API — setup选项

### 写法

```vue
<script>
    export default {
        setup() {
            //...
        },
        beforeCreate() {
            //...
        }
    }
</script>
```



### 执行时机

![setup执行时机](./images/setup执行时机.png)

setup在beforeCreate之前执行

```vue
<script>
export default {
    setup() {
        console.log('setup')
    },
    beforeCreate() {
        console.log('beforeCreate')
    }
}
</script>

<template>
    <div>this is div</div>
</template>
```

![setup执行结果](./images/setup执行结果.png)

### 在setup中写代码的特点

在setup中定义的数据，必须通过一个对象return出去，才能在外部使用

```vue
<script>
export default {
    setup() {
        console.log('setup')
        const message = 'this is message'
        const logMsg = () => {
            console.log(message)
        }

        return {
            message,
            logMsg
        }
    },
    beforeCreate() {
        console.log('beforeCreate')
    }
}
</script>

<template>
    <div>{{ message }}</div>
    <br>
    <button @click="logMsg">Click</button>
</template>
```

如此反复定义和return实在太过麻烦，于是Vue3提供了一个<span style="color:red;"><b>语法糖：就是script标签上的setup</b></span>，可以将上述代码简化成如下

```vue
<script setup>
const message = 'this is message'
const logMsg = () => {
    console.log(message)
}
</script>

<template>
    <div>{{ message }}</div>
    <br>
    <button @click="logMsg">Click</button>
</template>
```

==注意：setup中的this不再指向组件实例，而是指向undefined==



## 组合式API — reactive和ref函数

### reactive()

作用：接收<span style="color:red;">对象类型数据的参数</span>并返回一个<span style="color:red;">响应式的对象</span>

核心步骤：

```vue
<script setup>
    // 导入函数
    import { reactive } from 'vue'
    // 执行函数 传入参数 变量接收
    const state = reactive(对象类型数据)
</script>
```

举例：

```vue
<script setup>
    import { reactive } from 'vue'
    const state = reactive({
        count: 0
    })
    const setCount = () => {
        state.count++
    }
</script>

<template>
	<div>
    	<button @click="setCount">{{ state.count }}</button>
    </div>
</template>
```



### ref()

作用：接收<span style="color:red;">简单类型或者对象类型的数据</span>并返回一个<span style="color:red;">响应式的对象</span>

核心步骤：

```vue
<script setup>
    // 导入函数
    import { ref } from 'vue'
    // 执行函数 传入参数 变量接收
    const count = ref(简单类型或复杂类型数据)
</script>
```

举例：

```vue
<script setup>
	import { ref } from 'vue'
    const state = ref(0)
    const setCount = () => {
        //脚本区域修改ref产生的响应式对象数据，必须通过.value属性
        count.value++
    }
</script>

<template>
	<div>
    	<button @click="setCount">{{ state.count }}</button>
    </div>
</template>
```



## 组合式API — computed函数

计算属性核心思想和Vue2的完全一致，组合式API下的计算属性只是修改了写法

核心步骤：

```vue
<script setup>
    // 导入函数
    import { computed } from 'vue'
    // 执行函数 变量接收 在回调参数中return计算值
    const computedState = computed(() => {
        return 基于响应式数据做计算之后的值
    })
</script>
```

举例：

```vue
<script setup>
    import { ref, computed } from 'vue'
    const list = ref([1,2,3,4,5,6,7,8])
    const computedList = computed(() => {
        return list.value.filter(it => it > 2)
    })
    
    //设置定时器，测试计算属性是否响应式的
    setTimeout(() => {
        list.value.push(9,10)
    }, 3000)
</script>

<template>
	<div>
    	原始响应式数组 = {{list}}
    </div>
	<div>
        计算属性数组 = {{computedList}}
    </div>
</template>
```



### 最佳实践

1.计算属性中不应该有”副作用“

- <span style="color:red;">比如异步请求/修改dom</span>

2.避免直接修改计算属性的值

- <span style="color:red;">计算属性应该是只读的</span>



## 组合式API — watch函数

作用：侦听一个或者多个数据的变化，数据变化时执行回调函数

两个额外参数：

- **immediate**：立即执行
- **deep**：深度侦听



### 侦听单个数据

```vue
<script setup>
	// 导入watch
    import { ref, watch } from 'vue'
    const count = ref(0)
    // 调用watch 侦听变化
    watch(count, (newValue, oldValue) => {
        console.log(`count发生了变化，旧值为${oldValue}，新值为${newValue}`)
    })
    const setCount = () => {
        count.value++
    }
</script>
```



### 侦听多个数据

同时侦听多个响应式数据的变化，不管哪个数据变化都需要执行回调

```vue
<script setup>
    import { ref, watch } from 'vue'
    const count = ref(0)
    const name = ref('cp')
    // 调用watch 侦听多个数据源
    watch(
    [count, name],
    ([newCount, newName], [oldCount, oldName]) => {
        console.log('count或者name变化了', [newCount, newName], [oldCount, oldName])
    })
    const setCount = () => { count.value = 1 }
    const setName = () => { name.value = 'zs' }
</script>
```



### immediate参数

在侦听器创建时立即出发回调，响应式数据变化之后继续执行回调

```vue
<script>
    import { ref, watch } from 'vue'
    const count = ref(0)
    // 在watch函数中传入第三个参数
    watch(count, () => {
		console.log('count变化了')
	}, {
        immediate: true
    })
    const setCount = () => { count.value = 1 }
</script>
```



### deep参数

默认机制：通过watch监听的ref对象默认是<span style="color:red;">浅层监听的，直接修改嵌套的对象属性不会触发回调执行，</span>需要开启deep选项

```vue
<script setup>
    import { ref, watch } from 'vue'
    const state = ref({ count: 0 })
    watch(state, () => console.log('数据变化了'), {
        deep: true //开启深度监听
    })
    
    const changeStateByCount = () => {
        //直接修改属性 -> 不会触发回调
        state.value.count++
    }
</script>
```

注意：<span style="color:red;">**deep存在性能损耗，尽量不开启deep**</span>



### 精确侦听

==在不开启deep的前提下，侦听age的变化，只有age变化时才执行回调==

```vue
<script setup>
    import { ref, watch } from 'vue'
    const info = ref({
        name: 'cp',
        age: 18
    })
    
    watch(
    () => state.value.age //把要监听的属性作为第一个参数传入
    () => {
        console.log('age变化了')
    })
</script>
```



## 组合式API — 生命周期函数

### Vue3生命周期API

（对比Vue2选项式）

![Vue3生命周期API对比](./images/Vue3生命周期API对比.png)



### 生命周期函数基本使用

1.导入生命周期函数

2.执行生命周期函数 传入回调

```vue
<script setup>
    import { onMounted } from 'vue'
    onMounted(() => {
        // 自定义逻辑
    })
</script>
```

3.生命周期函数是可以执行多次的，多次执行时传入的回调会在<span style="color:red;">时机成熟时依次执行</span>

```vue
<script setup>
    import { onMounted } from 'vue'
    onMounted(() => {
        console.log('组件挂载完毕，mounted执行了1')
    })
    
    onMounted(() => {
        console.log('组件挂载完毕，mounted执行了2')
    })
</script>
```



## 组合式API — 父子通信

### 父传子

基本思想：

1.父组件中给子组件绑定属性

```vue
<script setup>
// 引入子组件
import SonCom from "@/components/son-com.vue";
</script>

<template>
    <div class="father">
        <h2>父组件App</h2>
        <!-- 1.绑定属性 message -->
        <son-com message="this is app message"/>
    </div>
</template>
```

2.子组件内部通过props选项接收

```vue
<script setup>
//2.通过defineProps接收数据
const props = defineProps({
    message: String
})

console.log(props)
</script>

<template>
    <div class="son">
        <h3>子组件Son</h3>
        <div>父组件传入的数据 - {{ message }}</div>
    </div>
</template>
```



**拓展**：传递响应式数据

```vue
<script setup>
// 引入子组件
import SonCom from "@/components/son-com.vue";

// 父给子传递响应式数据
import {ref} from 'vue'
const count = ref(100)
// 延时引起数据变化
setTimeout(() => {
    count.value = 200
}, 3000)
</script>

<template>
    <div class="father">
        <h2>父组件App</h2>
        <!-- 1.绑定属性 message -->
        <son-com message="this is app message" :count="count"/>
    </div>
</template>
```



```vue
<script setup>
//2.通过defineProps接收数据
const props = defineProps({
    message: String,
    count: Number
})

console.log(props)
</script>

<template>
    <div class="son">
        <h3>子组件Son</h3>
        <div>父组件传入的数据 - {{ message }} - {{count}}</div>
    </div>
</template>
```



#### 关于defineProps函数

编译器宏函数之一，这一类函数的主要作用就是==在编译时把函数中传入的代码转变为Vue2中我们所熟悉的形式==，例如这里

![编译器宏函数的作用原理](./images/编译器宏函数的作用原理.png)



### 子传父

基本思想：

1.父组件中给子组件标签通过@绑定事件

```vue
<script setup>
// 引入子组件
import SonCom from "@/components/son-com.vue";

const getMessage = msg => {
    console.log(msg)
}
</script>

<template>
    <!--1.绑定自定义事件-->
    <son-com @getMsg="getMessage"/>
</template>
```

2.子组件内部通过$emit方法触发事件

```vue
<script setup>
// 2.通过defineEmits编译器宏生成emit方法
const emit = defineEmits(['getMsg'])

const setMessage = () => {
    emit('getMsg', 'this is son msg')
}
</script>

<template>
    <button @click="setMessage">sendMessage</button>
</template>
```

<span style="color:green;"><b>原理简述：在父组件中给子组件绑定一个函数，该函数专门用来接收和处理从子组件中传过来的数据；</b></span>

<span style="color:blue;"><b>在子组件中通过定义的emit函数来调用父组件中绑定的数据处理函数</b></span>



## 组合式API — 模板引用

概念：通过ref标识，获取真实的dom对象或者组件实例对象

使用：

1.通过ref函数生成一个ref对象

2.通过ref标识绑定ref对象到标签

![模板引用的使用方式](./images/模板引用的使用方式.png)

实例：通过模板引用获取自定义组件实例对象

```vue
<script setup>
import {onMounted, ref} from "vue";
import SonCom from "@/components/son-com.vue";

// 1.调用ref函数得到ref对象
const sonRef = ref(null)

// 组件挂载完毕才能获取到dom元素
onMounted(() => {
    console.log(sonRef.value)
})
</script>

<template>
    <!--2.通过ref标识绑定ref对象-->
    <son-com ref="sonRef"/>
</template>
```

==注意：==其中**SonCom**组件实例的定义如下：

```vue
<script setup>

import {ref} from "vue";

const name = ref('test name')
const setName = () => {
    name.value = 'test new name'
}
</script>

<template>
    <div>我是son组件</div>
</template>
```

但是，我们通过模板引用获取组件实例的打印结果却如下：

![通过模板引用获取组件实例的打印输出](./images/通过模板引用获取组件实例的打印输出.png)

<span style="color:red;">那么问题来了：为什么我们通过模板引用获取的组件实例中没有看到我们在组件中定义的东西？</span>

那是因为**默认情况下，在&lt;script setup&gt;语法糖下，组件内部的属性和方法是不开放给父组件访问的**

我们可以通过编译宏**defineExpose**指定要暴露的属性和方法

```vue
<script setup>

import {ref} from "vue";

const name = ref('test name')
const setName = () => {
    name.value = 'test new name'
}

// 通过defineExpose编译器宏指定哪些东西要暴露给外部
defineExpose({
    name,
    setName
})
</script>

<template>
    <div>我是son组件</div>
</template>
```

![通过defineExpose暴露属性和方法](./images/通过defineExpose暴露属性和方法.png)



## 组合式API — provide和inject

作用：顶层组件向任意的底层组件<span style="color:red;">传递数据和方法</span>，实现跨层组件通信

### 跨层传递普通数据

1.顶层组件通过<span style="color:red;">provide函数</span>提供数据

```vue
<script setup>
import RoomMsgItem from "@/components/room-msg-item.vue";
import {provide} from "vue";
// 组件嵌套关系：
// RoomPage -> RoomMsgItem -> RoomMsgComment

// 1.顶层组件提供数据
provide('data-key', 'this is room data')
</script>

<template>
    <div>
        顶层组件
        <RoomMsgItem style="margin: 20px;"/>
    </div>
</template>
```

2.底层组件通过<span style="color:red;">inject函数</span>获取数据

```vue
<script setup>
import {inject} from "vue";

// 2.接收数据
const roomData = inject('data-key')
</script>

<template>
  <div class="comment">
      底层组件：
      <div>来自顶层组件中的数据为：{{roomData}}</div>
  </div>
</template>
```



### 跨层传递响应式数据

在调用**provide**函数时，第二个参数设置为ref对象：

```vue
<script setup>
import RoomMsgItem from "@/components/room-msg-item.vue";
import {provide, ref} from "vue";
// 组件嵌套关系：
// RoomPage -> RoomMsgItem -> RoomMsgComment

// 1.顶层组件提供数据
provide('data-key', 'this is room data')

const count = ref(0)
// 传递响应式数据
provide('count-key', count)

setTimeout(() => {
    count.value++
}, 1000)

</script>

<template>
    <div>
        顶层组件
        <RoomMsgItem style="margin: 20px;"/>
    </div>
</template>
```

获取数据的方式不变：

```vue
<script setup>
import {inject} from "vue";

// 2.接收数据
const roomData = inject('data-key')

// 接收响应式数据
const countData = inject('count-key')

</script>

<template>
    <div class="comment">
        底层组件：
        <div>来自顶层组件中的数据为：{{ roomData }}</div>
        <div>来自顶层组件的响应式数据为：{{ countData }}</div>
    </div>
</template>
```



### 跨层传递方法

在调用**provide**函数时，第二个参数设置为方法对象：

```vue
<script setup>
import RoomMsgItem from "@/components/room-msg-item.vue";
import {provide, ref} from "vue";
// 组件嵌套关系：
// RoomPage -> RoomMsgItem -> RoomMsgComment

// 1.顶层组件提供数据
provide('data-key', 'this is room data')

const count = ref(0)
// 传递响应式数据
provide('count-key', count)

setTimeout(() => {
    count.value++
}, 1000)

const setCount = () => {count.value++}
// 跨层传递方法(原则：谁的数据谁负责修改，所以要传入方法)
provide('setCount-key', setCount)

</script>

<template>
    <div>
        顶层组件
        <RoomMsgItem style="margin: 20px;"/>
    </div>
</template>
```

获取方法：

```vue
<script setup>
import {inject} from "vue";

// 2.接收数据
const roomData = inject('data-key')

// 接收响应式数据
const countData = inject('count-key')

// 在底层组件也可以修改顶层组件传入的响应式数据的值
// setTimeout(() => {countData.value++}, 2000)

// 接收方法
const setCount = inject('setCount-key')

</script>

<template>
    <div class="comment">
        底层组件：
        <div>来自顶层组件中的数据为：{{ roomData }}</div>
        <div>来自顶层组件的响应式数据为：{{ countData }}</div>
        <div>
            <button @click="setCount">修改顶层组件的数据count</button>
        </div>
    </div>
</template>
```



## 综合案例

实现页面中的功能：

- 列表渲染
- 删除
- 编辑

![综合案例页面](./images/综合案例页面.png)

详见项目：`vue3-case`



## Pinia

Pinia是Vue的专属的最新<span style="color:red;">状态管理库</span>，是Vuex的替代品

优势：

![Pinia的优势](./images/Pinia的优势.png)

### 在Vue项目中添加Pinia

安装Pinia：`npm install pinia`

在项目中引入Pinia

```js
import { createApp } from 'vue'
import App from './App.vue'

// 1.导入createPinia
import {createPinia} from "pinia"

// 2.执行方法得到实例
const pinia = createPinia()

// 3.把Pinia实例加入到app应用中
createApp(App).use(pinia).mount('#app')

```



### 基础使用

定义Store

```js
import {defineStore} from "pinia"
import {ref} from "vue";

// 写法一
// export const useCounterStore = defineStore('counter', {
//     state: () => {
//         return {
//             count: 0
//         }
//     },
//     actions: {
//         increment() {
//             this.count++
//         }
//     }
// })

// 写法二
export const useCounterStore = defineStore('counter', () => {
    // 数据（state）
    const count = ref(0)
    // 修改数据的方法（action）
    const increment = () => {
        count.value++
    }

    // 以对象形式返回
    return {count, increment}
})
```

在组件中使用

```vue
<script setup>
// 1.导入 use 打头的方法
import {useCounterStore} from "@/stores/counter";

// 2.执行方法得到store实例对象
const counterStore = useCounterStore()
</script>

<template>
  <button @click="counterStore.increment">{{counterStore.count}}</button>
</template>

<style scoped>
</style>
```



### getters

Pinia中的getters直接使用**computed**函数进行模拟

```js
import {defineStore} from "pinia"
import {computed, ref} from "vue";

// 写法二
export const useCounterStore = defineStore('counter', () => {
    // 数据（state）
    const count = ref(0)
    // 修改数据的方法（action 支持同步+异步）
    const increment = () => {
        count.value++
    }
    // getter 定义
    const doubleCount = computed(() => count.value * 2)

    // 以对象形式返回
    return {count, increment, doubleCount}
})
```

在组件中使用

```vue
<script setup>
// 1.导入 use 打头的方法
import {useCounterStore} from "@/stores/counter";

// 2.执行方法得到store实例对象
const counterStore = useCounterStore()
</script>

<template>
  <button @click="counterStore.increment">{{counterStore.count}}</button>
  &nbsp;{{counterStore.doubleCount}}
</template>

<style scoped>
</style>
```



### 异步action

action如何实现异步：action中实现异步和组件中定义数据、方法的风格完全一致

```js
const API_URL = 'http://geek.itheima.net/v1_0/channels'
// 准备数据（state）
const list = ref([])
// 异步action
const loadList = async () => {
    const res = await axios.get(API_URL)
    list.value = res.data.data.channels
}
```



### storeToRefs

使用storeToRefs函数可以辅助保持数据（state + getter）的响应式结构

```js
// 数据直接解构赋值（响应式丢失）
const {count, doubleCount} = counterStore

// 方法包裹（保持响应式更新）
const {count, doubleCount} = storeToRefs(counterStore)

// 方法直接从原来的store中解构赋值
const {increment} = counterStore
```



## 项目开发

### 项目初始化

![项目初始化](./images/项目初始化.png)

规范项目结构，src目录调整

![src目录调整](./images/src目录调整.png)



### 配置别名路径联想提示

在编写代码的过程中，一旦输入 `@/`，IDE会立刻联想出src下的所有子目录和文件，同一文件路径访问不容易出错

步骤：

1.在项目的根目录下，新增jsconfig.json文件

2.添加json格式的配置项

```json
{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "@/*": [
        "src/*"
      ]
    }
  }
}
```

==注意==：

上述配置项只做联想提示，实际的路径转换 @ -> src 在vite.config.js中

```js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    // 实际的路径转换 @ -> src
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})
```



### elementPlus按需导入

![项目的组件分类](./images/项目的组件分类.png)

引入elementPlus并配置其按需导入

[官方文档](https://element-plus.gitee.io/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5)

依次执行以下命令：

elementPlus安装：`npm install element-plus --save`

按需导入所用插件：`npm install -D unplugin-vue-components unplugin-auto-import`

在vite.config.js中添加配置：

```js
plugins: [
    vue(),
    // 配置elementPlus按需导入
    AutoImport({
        resolvers: [ElementPlusResolver()],
    }),
    Components({
        resolvers: [ElementPlusResolver()],
    })
]
```



### elementPlus主题定制

为了让整个项目有自己的风格，我们需要定制elementPlus主题

定制方式如下：

![elementPlus主题定制方式](./images/elementPlus主题定制方式.png)

1.运行命令：`npm i sass -D`

2.创建 **styles/element/index.scss**

```scss
/* 只需要重写你需要的即可 */
@forward 'element-plus/theme-chalk/src/common/var.scss' with (
  $colors: (
    'primary': (
      // 主色
      'base': #27ba9b,
    ),
    'success': (
      // 成功色
      'base': #1dc779,
    ),
    'warning': (
      // 警告色
      'base': #ffb302,
    ),
    'danger': (
      // 危险色
      'base': #e26237,
    ),
    'error': (
      // 错误色
      'base': #cf4444,
    ),
  )
);
```

3.在**vite.config.js**中配置：

①配置elementPlus采用

②自动导入定制化样式文件进行样式覆盖

```js
import {fileURLToPath, URL} from 'node:url'

import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'

// 配置elementPlus按需导入
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import {ElementPlusResolver} from 'unplugin-vue-components/resolvers'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [
        vue(),
        // 配置elementPlus按需导入
        AutoImport({
            resolvers: [ElementPlusResolver()],
        }),
        Components({
            resolvers: [
                // 1.配置elementPlus采用sass样式配色系统
                ElementPlusResolver({ importStyle: 'sass'})
            ],
        })
    ],
    resolve: {
        // 实际的路径转换 @ -> src
        alias: {
            '@': fileURLToPath(new URL('./src', import.meta.url))
        }
    },
    css: {
        preprocessorOptions: {
            scss: {
                // 2.自动导入定制化样式文件进行样式覆盖
                additionalData: `@use "@/styles/element/index.scss" as *;`
            }
        }
    }
})
```

4.运行项目，使用el-button按钮组件进行验证

![elementPlus主题定制验证](./images/elementPlus主题定制验证.png)



### axios基础配置

1.安装axios：`npm i axios`

2.配置基础实例（统一接口配置），将axios封装为  **utils/http.js**

![axios配置基础实例](./images/axios配置基础实例.png)

```js
// axios基础的封装
// 1.引入axios
import axios from 'axios'

// 2.创建axios实例
const httpInstance = axios.create({
    // http://pcapi-xiaotuxian-front-devtest.iteheima.net
    baseURL: 'http://pcapi-xiaotuxian-front-devtest.itheima.net', //根域名
    timeout: 5000, //请求超时时间
})

// 3.配置axios拦截器

// axios请求拦截器
httpInstance.interceptors.request.use(
    config => {
        return config
    },
    e => Promise.reject(e)
)

// axios响应拦截器
httpInstance.interceptors.response.use(
    res => res.data,
    e => Promise.reject(e)
)

// 4.暴露axios实例
export default httpInstance
```

3.编写接口函数**testAPI.js**，测试axios封装

```js
import httpInstance from "@/utils/http";

export function getCategory() {
    return httpInstance({
        url: '/home/category/head',
    })
}
```

在main.js中引入并调用，查看打印的结果

```js
// 测试接口函数
import {getCategory} from "@/apis/testAPI";
getCategory().then(res => {
    console.log(res);
})
```



==如果项目里面不同的业务模块需要的接口基地址不同==

我们可以创建多个axios实例：

```js
const http1 = axios.create({ baseURL: 'url1' })
const http2 = axios.create({ baseURL: 'url2' })
```



### 项目整体路由设计

#### 设计一级路由

<span style="color:red;">**路由设计的原则**：找内容切换的区域，如果是页面整体切换，则为一级路由</span>

首页和登录页的路由：

- 首页路径 path:#/
- 登录页路径 path:#/login

1、创建两个一级路由组件

`views/Login/index.vue`

```vue
<template>
    <div>我是首页</div>
</template>
```

`views/Layout/index.vue`

```vue
<template>
    <div>我是登录页</div>
</template>
```



==ESLint会对组件命名有一个multi-word检查，我们可以在 **.eslintrc.cjs** 中配置取消这个检查==

```js
  rules: {
    'vue/multi-word-component-names': 0, //不再强制要求组件命名
  }
```



2、配置组件对应的访问路由

在**router/index.js**中配置组件的路由

```js
// createRouter：创建router实例对象
// createWebHistory：创建history模式的路由
import { createRouter, createWebHistory } from 'vue-router'
import Layout from "@/views/Layout/index.vue";
import Login from "@/views/Login/index.vue";

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),

  // path和component对应关系的位置
  routes: [
    {
      path: '/',
      component: Layout
    },
    {
      path: '/login',
      component: Login
    }
  ]
})

export default router
```

在**App.vue**中添加一级路由的出口

```vue
<script setup>
</script>

<template>
  <!--一级路由的出口组件-->
  <router-view/>
</template>

<style scoped>
</style>
```



3、运行项目访问两个路由



#### 设计二级路由

<span style="color:red;">**路由设计的原则**：找内容切换的区域，如果是一级路由页的内部切换，则为二级路由</span>

分类页和默认Home页的路由：

- 分类页路径 path:#/category
- 默认Home页路径 path:#/home

1、创建两个二级路由组件

`views/Category/index.vue`

```vue
<template>
    <div>我是分类页</div>
</template>
```

`views/Home/index.vue`

```vue
<template>
    <div>我是Home页</div>
</template>
```



2、配置组件对应的访问路由

```js
    {
      path: '/',
      component: Layout,
      children: [
        {
          path: '', //由于Home是默认渲染的页面，所以我们可以将其路由置空，以此达到默认渲染此页面的效果
          component: Home
        },
        {
          path: '/category',
          component: Category
        }
      ]
    },
```

在**Layout/index.vue**中添加二级路由的出口

```vue
<template>
    <div>
        我是首页
        <!--二级路由出口-->
        <router-view/>
    </div>
</template>
```



3、运行项目访问两个路由



#### 总结

1.路由设计的依据：

- 内容切换的方式

2.默认二级路由如何进行设置：

- path项配置为空



### 静态资源初始化

资源说明

1.实际工作中的图片资源通常由UI设计师提供，常见的图片格式有png、svg等都是由UI切图交给前端

2.样式资源通常是指项目初始化的时候进行样式重置，常见的比如开源的normalize,css或者手写



资源操作

- 图片资源 - 把images文件夹 放到**asserts**目录下
- 样式资源 - 把common.scss文件 放到**styles**目录下

在**main.js**中引入common.scss文件



### scss文件自动导入

在项目里，一些组件共享的色值会以scss变量的方式统一放到一个名为**var.scss**的文件中，

正常组件中使用，需要先导入scss文件，再使用内部的变量，比较繁琐，

自动导入可以省去导入，直接使用内部变量

1.新增一个var.scss文件，存入色值变量

2.通过**vite.config.js**配置自动导入文件

```js
    css: {
        preprocessorOptions: {
            scss: {
                // 2.自动导入定制化样式文件进行样式覆盖
                additionalData: `
                @use "@/styles/element/index.scss" as *;
                @use "@/styles/var.scss" as *;
                `,
            }
        }
    }
```

在App.vue中测试自动导入

### ————————

### 搭建静态模板结构

根据UI设计稿去将**首页面**拆分为多块，每块对应一个组件

#### 顶部导航

`LayoutNav.vue`

```vue
<template>
    <nav class="app-tonav">
        <div class="container">
            <ul>
                <template v-if="true">
                    <li><a href="javascript:"><i class="iconfont icon-user"></i>周杰伦</a></li>
                    <li>
                        <el-popconfirm title="确认退出吗？" confirm-button-text="确认" cancel-button-text="取消">
                            <template #reference>
                                <a href="javascript:">退出登录</a>
                            </template>
                        </el-popconfirm>
                    </li>
                    <li><a href="javascript:">我的订单</a></li>
                    <li><a href="javascript:">会员中心</a></li>
                </template>
                <template v-else>
                    <li><a href="javascript:">请先登录</a></li>
                    <li><a href="javascript:">帮助中心</a></li>
                    <li><a href="javascript:">关于我们</a></li>
                </template>
            </ul>
        </div>
    </nav>
</template>

<style scoped lang="scss">
.app-tonav {
  background: #333;

  ul {
    display: flex;
    height: 53px;
    justify-content: flex-end;
    align-items: center;

    li {
      a {
        padding: 0 15px;
        color: #cdcdcd;
        line-height: 1;
        display: inline-block;

        i {
          font-size: 14px;
          margin-right: 2px;
        }

        &:hover {
          color: $xtxColor;
        }
      }

      ~ li {
        a {
          border-left: 2px solid #666;
        }
      }
    }
  }
}
</style>
```



#### 页首

`LayoutHeader.vue`

```vue
<template>
    <header class="app-header">
        <div class="container">
            <h1 class="logo">
                <router-link to="/">小兔鲜</router-link>
            </h1>
            <ul class="app-header-nav">
                <li class="home">
                    <router-link to="/">首页</router-link>
                </li>
                <li>
                    <router-link to="/">居家</router-link>
                </li>
                <li>
                    <router-link to="/">美食</router-link>
                </li>
                <li>
                    <router-link to="/">服饰</router-link>
                </li>
            </ul>
            <div class="search">
                <i class="iconfont icon-search"></i>
                <input type="text" placeholder="搜一搜">
            </div>
            <!--头部购物车-->
        </div>
    </header>
</template>

<style scoped lang="scss">
.app-header {
  background: #fff;

  .container {
    display: flex;
    align-items: center;
  }

  .logo {
    width: 200px;

    a {
      display: block;
      height: 132px;
      width: 100%;
      text-indent: -9999px;
      background: url('@/assets/images/logo.png') no-repeat center 18px / contain;
    }
  }

  .app-header-nav {
    width: 820px;
    display: flex;
    padding-left: 40px;
    position: relative;
    z-index: 998;

    li {
      margin-right: 40px;
      width: 38px;
      text-align: center;

      a {
        font-size: 16px;
        line-height: 32px;
        height: 32px;
        display: inline-block;

        &:hover {
          color: $xtxColor;
          border-bottom: 1px solid $xtxColor;
        }
      }

      .active {
        color: $xtxColor;
        border-bottom: 1px solid $xtxColor;
      }
    }
  }

  .search {
    width: 170px;
    height: 32px;
    position: relative;
    border-bottom: 1px solid #e7e7e7;
    line-height: 32px;

    .icon-search {
      font-size: 18px;
      margin-left: 5px;
    }

    input {
      width: 140px;
      padding-left: 5px;
      color: #666;
    }
  }

  .cart {
    width: 50px;

    .curr {
      height: 32px;
      line-height: 32px;
      text-align: center;
      position: relative;
      display: block;

      .icon-cart {
        font-size: 22px;
      }

      em {
        font-style: normal;
        position: absolute;
        right: 0;
        top: 0;
        padding: 1px 6px;
        line-height: 1;
        background: $helpColor;
        color: #fff;
        font-size: 12px;
        border-radius: 10px;
        font-family: Arial,serif;
      }
    }
  }
}
</style>
```



#### 二级路由出口

`router-view`



#### 页脚

`LayoutFooter.vue`

```vue
<template>
    <footer class="app_footer">
        <!-- 联系我们 -->
        <div class="contact">
            <div class="container">
                <dl>
                    <dt>客户服务</dt>
                    <dd><i class="iconfont icon-kefu"></i> 在线客服</dd>
                    <dd><i class="iconfont icon-question"></i> 问题反馈</dd>
                </dl>
                <dl>
                    <dt>关注我们</dt>
                    <dd><i class="iconfont icon-weixin"></i> 公众号</dd>
                    <dd><i class="iconfont icon-weibo"></i> 微博</dd>
                </dl>
                <dl>
                    <dt>下载APP</dt>
                    <dd class="qrcode"><img src="@/assets/images/qrcode.jpg"/></dd>
                    <dd class="download">
                        <span>扫描二维码</span>
                        <span>立马下载APP</span>
                        <a href="javascript:;">下载页面</a>
                    </dd>
                </dl>
                <dl>
                    <dt>服务热线</dt>
                    <dd class="hotline">400-0000-000 <small>周一至周日 8:00-18:00</small></dd>
                </dl>
            </div>
        </div>
        <!-- 其它 -->
        <div class="extra">
            <div class="container">
                <div class="slogan">
                    <a href="javascript:;">
                        <i class="iconfont icon-footer01"></i>
                        <span>价格亲民</span>
                    </a>
                    <a href="javascript:;">
                        <i class="iconfont icon-footer02"></i>
                        <span>物流快捷</span>
                    </a>
                    <a href="javascript:;">
                        <i class="iconfont icon-footer03"></i>
                        <span>品质新鲜</span>
                    </a>
                </div>
                <!-- 版权信息 -->
                <div class="copyright">
                    <p>
                        <a href="javascript:;">关于我们</a>
                        <a href="javascript:;">帮助中心</a>
                        <a href="javascript:;">售后服务</a>
                        <a href="javascript:;">配送与验收</a>
                        <a href="javascript:;">商务合作</a>
                        <a href="javascript:;">搜索推荐</a>
                        <a href="javascript:;">友情链接</a>
                    </p>
                    <p>CopyRight © 小兔鲜儿</p>
                </div>
            </div>
        </div>
    </footer>
</template>

<style scoped lang='scss'>
.app_footer {
  overflow: hidden;
  background-color: #f5f5f5;
  padding-top: 20px;

  .contact {
    background: #fff;

    .container {
      padding: 60px 0 40px 25px;
      display: flex;
    }

    dl {
      height: 190px;
      text-align: center;
      padding: 0 72px;
      border-right: 1px solid #f2f2f2;
      color: #999;

      &:first-child {
        padding-left: 0;
      }

      &:last-child {
        border-right: none;
        padding-right: 0;
      }
    }

    dt {
      line-height: 1;
      font-size: 18px;
    }

    dd {
      margin: 36px 12px 0 0;
      float: left;
      width: 92px;
      height: 92px;
      padding-top: 10px;
      border: 1px solid #ededed;

      .iconfont {
        font-size: 36px;
        display: block;
        color: #666;
      }

      &:hover {
        .iconfont {
          color: $xtxColor;
        }
      }

      &:last-child {
        margin-right: 0;
      }
    }

    .qrcode {
      width: 92px;
      height: 92px;
      padding: 7px;
      border: 1px solid #ededed;
    }

    .download {
      padding-top: 5px;
      font-size: 14px;
      width: auto;
      height: auto;
      border: none;

      span {
        display: block;
      }

      a {
        display: block;
        line-height: 1;
        padding: 10px 25px;
        margin-top: 5px;
        color: #fff;
        border-radius: 2px;
        background-color: $xtxColor;
      }
    }

    .hotline {
      padding-top: 20px;
      font-size: 22px;
      color: #666;
      width: auto;
      height: auto;
      border: none;

      small {
        display: block;
        font-size: 15px;
        color: #999;
      }
    }
  }

  .extra {
    background-color: #333;
  }

  .slogan {
    height: 178px;
    line-height: 58px;
    padding: 60px 100px;
    border-bottom: 1px solid #434343;
    display: flex;
    justify-content: space-between;

    a {
      height: 58px;
      line-height: 58px;
      color: #fff;
      font-size: 28px;

      i {
        font-size: 50px;
        vertical-align: middle;
        margin-right: 10px;
        font-weight: 100;
      }

      span {
        vertical-align: middle;
        text-shadow: 0 0 1px #333;
      }
    }
  }

  .copyright {
    height: 170px;
    padding-top: 40px;
    text-align: center;
    color: #999;
    font-size: 15px;

    p {
      line-height: 1;
      margin-bottom: 20px;
    }

    a {
      color: #999;
      line-height: 1;
      padding: 0 10px;
      border-right: 1px solid #999;

      &:last-child {
        border-right: none;
      }
    }
  }
}
</style>
```



### 引入字体图标

阿里的字体图标库支持多种引入方式，这里采用的是<span style="color:red;">font-class引用</span>的方式

```html
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="src/assets/iconfont/iconfont.css">
    <title>小兔鲜</title>
  </head>
```

[阿里图标官网](https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a) --> 顶部“帮助” --> 代码应用 

![阿里图标-代码应用](./images/阿里图标-代码应用.png)

font-class引用

![font-class引用](./images/font-class引用.png)

首先挑选你需要的图标，将它们加入购物车，

然后在购物车中将其全部添加到同一个项目，在项目中生成css源码，

将图标生成的css代码下载到`src/assets/iconfont/iconfont.css`中，接着在组件中就可以使用图标了



### 渲染一级导航

使用后端接口，渲染一级路由导航

1、封装后端接口函数：layout.js

```js
import httpInstance from "@/utils/http"

export function getCategoryAPI() {
    return httpInstance({
        url: '/home/category/head',
        method: 'get'
    })
}
```

2、调用函数，发送请求，获取数据列表：LayoutHeader.vue

```vue
<script setup>
import {getCategoryAPI} from "@/apis/layout";
import {onMounted, ref} from "vue";

const categoryList = ref([])
const getCategory = async () => {
    const res = await getCategoryAPI()
    categoryList.value = res.result
}

onMounted(() =>{
    getCategory()
})
</script>
```

3、渲染页面

```vue
<template>
    <header class="app-header">
        <div class="container">
            <h1 class="logo">
                <router-link to="/">小兔鲜</router-link>
            </h1>
            <!--渲染一级导航-->
            <ul class="app-header-nav">
                <li class="home" v-for="item in categoryList" :key="item.id">
                    <router-link to="/">{{ item.name }}</router-link>
                </li>
            </ul>
            <div class="search">
                <i class="iconfont icon-search"></i>
                <input type="text" placeholder="搜一搜">
            </div>
            <!--头部购物车-->
        </div>
    </header>
</template>
```



### 吸顶导航交互实现

要求：浏览器在上下滚动的过程中，如果距离顶部的滚动距离大于78px，吸顶导航显示，小于78px隐藏

1、创建组件 LayoutFixed.vue

```vue
<script setup>

</script>

<template>
    <div class="app-header-sticky">
        <div class="container">
            <RouterLink class="logo" to="/" />
            <!-- 导航区域 -->
            <ul class="app-header-nav ">
                <li class="home">
                    <RouterLink to="/">首页</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">居家</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">美食</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">服饰</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">母婴</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">个护</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">严选</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">数码</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">运动</RouterLink>
                </li>
                <li>
                    <RouterLink to="/">杂项</RouterLink>
                </li>
            </ul>

            <div class="right">
                <RouterLink to="/">品牌</RouterLink>
                <RouterLink to="/">专题</RouterLink>
            </div>
        </div>
    </div>
</template>


<style scoped lang='scss'>
.app-header-sticky {
  width: 100%;
  height: 80px;
  position: fixed;
  left: 0;
  top: 0;
  z-index: 999;
  background-color: #fff;
  border-bottom: 1px solid #e4e4e4;
  // 此处为关键样式!!!
  // 状态一：往上平移自身高度 + 完全透明
  transform: translateY(-100%);
  opacity: 0;

  // 状态二：移除平移 + 完全不透明
  &.show {
    transition: all 0.3s linear;
    transform: none;
    opacity: 1;
  }

  .container {
    display: flex;
    align-items: center;
  }

  .logo {
    width: 200px;
    height: 80px;
    background: url("@/assets/images/logo.png") no-repeat right 2px;
    background-size: 160px auto;
  }

  .right {
    width: 220px;
    display: flex;
    text-align: center;
    padding-left: 40px;
    border-left: 2px solid $xtxColor;

    a {
      width: 38px;
      margin-right: 40px;
      font-size: 16px;
      line-height: 1;

      &:hover {
        color: $xtxColor;
      }
    }
  }
}

.app-header-nav {
  width: 820px;
  display: flex;
  padding-left: 40px;
  position: relative;
  z-index: 998;

  li {
    margin-right: 40px;
    width: 38px;
    text-align: center;

    a {
      font-size: 16px;
      line-height: 32px;
      height: 32px;
      display: inline-block;

      &:hover {
        color: $xtxColor;
        border-bottom: 1px solid $xtxColor;
      }
    }

    .active {
      color: $xtxColor;
      border-bottom: 1px solid $xtxColor;
    }
  }
}
</style>
```

2、使用**vueUse**来获取浏览器的滚动值

安装vueUse：`npm i @vueuse/core`

在吸顶导航组件中使用useScroll来获取浏览器滚动值

```vue
<script setup>
import {useScroll} from "@vueuse/core"
// 获取页面滚动值
const {y} = useScroll(window)
</script>

<template>
    <div class="app-header-sticky" :class="{show: y > 78}">
    ...
```



### Pinia优化重复请求

吸顶导航组件中渲染的菜单数据也是需要通过请求后端获取的，其与页首导航的数据是一样的，所以我们只需要请求一次后端即可

优化方案如下：

![Pinia优化重复请求的方案](./images/Pinia优化重复请求的方案.png)

`category.js`

```js
import {defineStore} from "pinia";
import {ref} from "vue";
import {getCategoryAPI} from "@/apis/layout";

export const useCategoryStore = defineStore('category', () => {
    // 导航列表的数据管理

    // state 导航列表数据
    const categoryList = ref([])

    // action 获取导航数据的方法
    const getCategoryList = async () => {
        const res = await getCategoryAPI()
        categoryList.value = res.result
    }

    return {categoryList, getCategoryList}
})import {defineStore} from "pinia";
import {ref} from "vue";
import {getCategoryAPI} from "@/apis/layout";

export const useCategoryStore = defineStore('category', () => {
    // 导航列表的数据管理

    // state 导航列表数据
    const categoryList = ref([])

    // action 获取导航数据的方法
    const getCategoryList = async () => {
        const res = await getCategoryAPI()
        categoryList.value = res.result
    }

    return {categoryList, getCategoryList}
})
```

在引用**LayoutHeader**和**LayoutFixed**组件的父组件**layout/index**中调用Pinia中的方法，请求并给Pinia中的数据赋值

```vue
<script setup>
import LayoutNav from "@/views/Layout/components/LayoutNav.vue"
import LayoutHeader from "@/views/Layout/components/LayoutHeader.vue"
import LayoutFooter from "@/views/Layout/components/LayoutFooter.vue"
import LayoutFixed from "@/views/Layout/components/LayoutFixed.vue"
// 触发获取导航列表的action
import {useCategoryStore} from "@/stores/category"
import {onMounted} from "vue"

const categoryStore = useCategoryStore()

onMounted(() => {categoryStore.getCategoryList()})
</script>
```

随后在两个组件中分别调用Pinia中的数据对页面进行渲染，如下：

```vue
<script setup>
import {useCategoryStore} from "@/stores/category"

const categoryStore = useCategoryStore()
</script>

<template>
    <header class="app-header">
        <div class="container">
            <h1 class="logo">
                <router-link to="/">小兔鲜</router-link>
            </h1>
            <!--渲染一级导航-->
            <ul class="app-header-nav">
                <li class="home">
                    <router-link to="/">首页</router-link>
                </li>
                <li class="home" v-for="item in categoryStore.categoryList" :key="item.id">
                    <router-link to="/">{{ item.name }}</router-link>
                </li>
            </ul>
            <div class="search">
                <i class="iconfont icon-search"></i>
                <input type="text" placeholder="搜一搜">
            </div>
            <!--头部购物车-->
        </div>
    </header>
</template>
```

### ————————

### Home页整体结构搭建

页面结构：

- 左侧分类 和 轮播图
- 新鲜好物
- 人气推荐
- 产品列表



### 分类实现

```vue
<script setup>
import {useCategoryStore} from "@/stores/category"

const categoryStore = useCategoryStore()
</script>

<template>
    <div class="home-category">
        <ul class="menu">
            <li v-for="item in categoryStore.categoryList" :key="item.id">
                <RouterLink to="/">{{ item.name }}</RouterLink>
                <RouterLink v-for="i in item.children.slice(0,2)" :key="i.id" to="/">{{ i.name }}</RouterLink>
                <!-- 弹层layer位置 -->
                <div class="layer">
                    <h4>分类推荐 <small>根据您的购买或浏览记录推荐</small></h4>
                    <ul>
                        <li v-for="i in item.goods" :key="i.id">
                            <RouterLink to="/">
                                <img alt="" :src="i.picture" />
                                <div class="info">
                                    <p class="name ellipsis-2">
                                        {{ i.name }}
                                    </p>
                                    <p class="desc ellipsis">{{ i.desc }}</p>
                                    <p class="price"><i>¥</i>{{i.price}}</p>
                                </div>
                            </RouterLink>
                        </li>
                    </ul>
                </div>
            </li>
        </ul>
    </div>
</template>


<style scoped lang='scss'>
.home-category {
  width: 250px;
  height: 500px;
  background: rgba(0, 0, 0, 0.8);
  position: relative;
  z-index: 99;

  .menu {
    li {
      padding-left: 40px;
      height: 55px;
      line-height: 55px;

      &:hover {
        background: $xtxColor;
      }

      a {
        margin-right: 4px;
        color: #fff;

        &:first-child {
          font-size: 16px;
        }
      }

      .layer {
        width: 990px;
        height: 500px;
        background: rgba(255, 255, 255, 0.8);
        position: absolute;
        left: 250px;
        top: 0;
        display: none;
        padding: 0 15px;

        h4 {
          font-size: 20px;
          font-weight: normal;
          line-height: 80px;

          small {
            font-size: 16px;
            color: #666;
          }
        }

        ul {
          display: flex;
          flex-wrap: wrap;

          li {
            width: 310px;
            height: 120px;
            margin-right: 15px;
            margin-bottom: 15px;
            border: 1px solid #eee;
            border-radius: 4px;
            background: #fff;

            &:nth-child(3n) {
              margin-right: 0;
            }

            a {
              display: flex;
              width: 100%;
              height: 100%;
              align-items: center;
              padding: 10px;

              &:hover {
                background: #e3f9f4;
              }

              img {
                width: 95px;
                height: 95px;
              }

              .info {
                padding-left: 10px;
                line-height: 24px;
                overflow: hidden;

                .name {
                  font-size: 16px;
                  color: #666;
                }

                .desc {
                  color: #999;
                }

                .price {
                  font-size: 22px;
                  color: $priceColor;

                  i {
                    font-size: 16px;
                  }
                }
              }
            }
          }
        }
      }

      // 关键样式  hover状态下的layer盒子变成block
      &:hover {
        .layer {
          display: block;
        }
      }
    }
  }
}
</style>
```



### 轮播图实现

编写接口调用函数

```js
import httpInstance from "@/utils/http";

// 获取banner
export function getBannerAPI() {
    return httpInstance({
        url: '/home/banner',
        method: 'get'
    })
}
```

使用ElementPlus提供的轮播图组件，渲染数据

```vue
<script setup>

import {onMounted, ref} from "vue"
import {getBannerAPI} from "@/apis/home";

const bannerList = ref([])

const getBannerList = async () => {
    const res = await getBannerAPI()
    bannerList.value = res.result
}

onMounted(() => {
    getBannerList()
})
</script>



<template>
    <div class="home-banner">
        <el-carousel height="500px">
            <el-carousel-item v-for="item in bannerList" :key="item.id">
                <img :src="item.imgUrl" alt="">
            </el-carousel-item>
        </el-carousel>
    </div>
</template>



<style scoped lang='scss'>
.home-banner {
    width: 1240px;
    height: 500px;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 98;

    img {
        width: 100%;
        height: 500px;
    }
}
</style>
```



### 面板组件封装

新鲜好物 和 人气推荐 的结构非常相似，通过组件封装可以实现复用结构的效果

==核心思路==：把可复用的结构只写一次，把<span style="color:red;">可能发生变化的部分抽象成组件参数（props / 插槽）</span>

实现步骤：

1.不做任何抽象，准备静态模板

2.抽象可变的部分

- 主标题 和 副标题 是纯文本，可以抽象成prop传入
- 主题内容是复杂的模板，抽象成插槽传入

```vue
<script setup>

defineProps({
    title: {type: String},
    subTitle: {type: String}
})
</script>


<template>
    <div class="home-panel">
        <div class="container">
            <div class="head">
                <!-- 主标题和副标题 -->
                <h3>
                    {{ title }}<small>{{ subTitle }}</small>
                </h3>
            </div>
            <!-- 主体内容区域 -->
            <slot/>
        </div>
    </div>
</template>

<style scoped lang='scss'>
.home-panel {
  background-color: #fff;

  .head {
    padding: 40px 0;
    display: flex;
    align-items: flex-end;

    h3 {
      flex: 1;
      font-size: 32px;
      font-weight: normal;
      margin-left: 6px;
      height: 35px;
      line-height: 35px;

      small {
        font-size: 16px;
        color: #999;
        margin-left: 20px;
      }
    }
  }
}
</style>
```



### 新鲜好物实现

编写接口函数

```js
// 获取新鲜好物
export function getNewAPI() {
    return httpInstance({
        url: '/home/new',
        method: 'get'
    })
}

// 获取人气推荐
export function getHotAPI() {
    return httpInstance({
        url: '/home/hot',
        method: 'get'
    })
}
```

调用接口函数，进行数据渲染

```vue
<script setup>
import HomePanel from "@/views/Home/components/HomePanel.vue"
import {onMounted, ref} from "vue";
import {getNewAPI} from "@/apis/home";

const newList = ref([])
const getNewList = async () => {
    const res = await getNewAPI()
    newList.value = res.result
}

onMounted(() => getNewList())
</script>

<template>
    <HomePanel title="新鲜好物" sub-title="新鲜出炉 品质靠谱">
        <ul class="goods-list">
            <li v-for="item in newList" :key="item.id">
                <router-link to="/">
                    <img :src="item.picture" alt=""/>
                    <p class="name">{{ item.name }}</p>
                    <p class="price">&yen;{{ item.price }}</p>
                </router-link>
            </li>
        </ul>
    </HomePanel>
</template>

<style scoped lang='scss'>
.goods-list {
  display: flex;
  justify-content: space-between;
  height: 406px;

  li {
    width: 306px;
    height: 406px;

    background: #f0f9f4;
    transition: all .5s;

    &:hover {
      transform: translate3d(0, -3px, 0);
      box-shadow: 0 3px 8px rgb(0 0 0 / 20%);
    }

    img {
      width: 306px;
      height: 306px;
    }

    p {
      font-size: 22px;
      padding-top: 12px;
      text-align: center;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }

    .price {
      color: $priceColor;
    }
  }
}
</style>
```



### 人气推荐实现

```vue
<script setup>
import {onMounted, ref} from "vue"
import {getHotAPI} from "@/apis/home";
import HomePanel from "@/views/Home/components/HomePanel.vue";

const hotList = ref([])
const getHotList = async () => {
    const res = await getHotAPI()
    hotList.value = res.result
}

onMounted(() => getHotList())
</script>

<template>
    <HomePanel title="人气推荐" sub-title="人气爆款 不容错过">
        <ul class="goods-list">
            <li v-for="item in hotList" :key="item.id">
                <router-link to="/">
                    <img :src="item.picture" :alt="item.alt"/>
                    <p class="name">{{ item.title }}</p>
                    <p class="desc">{{ item.alt }}</p>
                </router-link>
            </li>
        </ul>
    </HomePanel>
</template>

<style scoped lang='scss'>
.goods-list {
    display: flex;
    justify-content: space-between;
    height: 426px;

    li {
        width: 306px;
        height: 406px;
        transition: all .5s;

        &:hover {
            transform: translate3d(0, -3px, 0);
            box-shadow: 0 3px 8px rgb(0 0 0 / 20%);
        }

        img {
            width: 306px;
            height: 306px;
        }

        p {
            font-size: 22px;
            padding-top: 12px;
            text-align: center;
        }

        .desc {
            color: #999;
            font-size: 18px;
        }
    }
}
</style>
```



### 图片懒加载实现

==场景==

电商网站的首页通常会很长，用户不一定能访问到页面靠下面的图片，这类图片通过懒加载优化手段可以做到<span style="color:red;">只有进入视线区域才发送图片和请求</span>



==指令用法==

```vue
<img v-img-lazy="item.picture"/>
```

在图片img身上绑定指令，该图片只有正式进入到视线区域才会发送图片网络请求



1.首先需要自定义指令

这里需要调用vueUse里的**useIntersectionObserver**函数来判断元素是否进入视线区域

如果进入了，则给元素附上src的属性

```js
import {useIntersectionObserver} from "@vueuse/core"

// 定义全局指令
app.directive('img-lazy', {
    mounted(el, binding) {
        // el：指令绑定的那个元素 img
        // binding：binding.value 指令等于号后面绑定的表达式的值 图片url
        console.log(el, binding.value)
        useIntersectionObserver(el, ([isIntersecting]) => {
            if (isIntersecting)
                el.src = binding.value
        })
    }
})
```

2.然后将需要懒加载的图片元素上的src属性替换成自定义指令

```vue
<img v-img-lazy="item.picture" :alt="item.alt"/>
```



==优化1==：将自定义指令封装为插件，在main.js中注册

`src/directives/index.js`

```js
import {useIntersectionObserver} from "@vueuse/core"

export const imgLazyPlugin = {
    install(app) {
        // 懒加载指令逻辑
        app.directive('img-lazy', {
            mounted(el, binding) {
                // el：指令绑定的那个元素 img
                // binding：binding.value 指令等于号后面绑定的表达式的值 图片url
                useIntersectionObserver(el, ([isIntersecting]) => {
                    if (isIntersecting)
                        // 图片进入视线区域，为其附上src属性
                        el.src = binding.value
                })
            }
        })
    }
}
```

在main.js中注册

```js
import {imgLazyPlugin} from "@/directives"

// 全局注册自定义指令
app.use(imgLazyPlugin)

app.mount('#app')
```



==优化2==：重复监听问题

useIntersectionObserver对于元素的监听是一直存在的，除非手动停止监听，存在<span style="color:red;">内存浪费</span>

解决思路：在监听的图片第一次完成加载之后就停止监听

```js
const {stop} = useIntersectionObserver(el, ([isIntersecting]) => {
    if (isIntersecting) {
        // 图片进入视线区域，为其附上src属性
        el.src = binding.value
        // 调用stop停止监听
        stop()
    }
})
```



### 产品列表实现

`src/apis/home.js`

```js
// 获取产品列表
export function getGoodsAPI() {
    return httpInstance({
        url: '/home/goods',
        method: 'get'
    })
}
```

`src/views/HomeProduct.vue`

```vue
<script setup>
import HomePanel from './HomePanel.vue'
import {onMounted, ref} from "vue";
import {getGoodsAPI} from "@/apis/home";

const goodsProduct = ref([])
const getGoodsProduct = async () => {
    const res = await getGoodsAPI()
    goodsProduct.value = res.result
}

onMounted(() => getGoodsProduct())
</script>

<template>
    <div class="home-product">
         <HomePanel :title="cate.name" v-for="cate in goodsProduct" :key="cate.id">
          <div class="box">
            <RouterLink class="cover" to="/">
              <img v-img-lazy="cate.picture" alt=""/>
              <strong class="label">
                <span>{{ cate.name }}馆</span>
                <span>{{ cate.saleInfo }}</span>
              </strong>
            </RouterLink>
            <ul class="goods-list">
              <li v-for="good in cate.goods" :key="good.id">
                <RouterLink to="/" class="goods-item">
                  <img v-img-lazy="good.picture" alt="" />
                  <p class="name ellipsis">{{ good.name }}</p>
                  <p class="desc ellipsis">{{ good.desc }}</p>
                  <p class="price">&yen;{{ good.price }}</p>
                </RouterLink>
              </li>
            </ul>
          </div>
        </HomePanel>
    </div>
</template>

<style scoped lang='scss'>
.home-product {
    background: #fff;
    margin-top: 20px;
    .sub {
        margin-bottom: 2px;

        a {
            padding: 2px 12px;
            font-size: 16px;
            border-radius: 4px;

            &:hover {
                background: $xtxColor;
                color: #fff;
            }

            &:last-child {
                margin-right: 80px;
            }
        }
    }

    .box {
        display: flex;

        .cover {
            width: 240px;
            height: 610px;
            margin-right: 10px;
            position: relative;

            img {
                width: 100%;
                height: 100%;
            }

            .label {
                width: 188px;
                height: 66px;
                display: flex;
                font-size: 18px;
                color: #fff;
                line-height: 66px;
                font-weight: normal;
                position: absolute;
                left: 0;
                top: 50%;
                transform: translate3d(0, -50%, 0);

                span {
                    text-align: center;

                    &:first-child {
                        width: 76px;
                        background: rgba(0, 0, 0, 0.9);
                    }

                    &:last-child {
                        flex: 1;
                        background: rgba(0, 0, 0, 0.7);
                    }
                }
            }
        }

        .goods-list {
            width: 990px;
            display: flex;
            flex-wrap: wrap;

            li {
                width: 240px;
                height: 300px;
                margin-right: 10px;
                margin-bottom: 10px;

                &:nth-last-child(-n + 4) {
                    margin-bottom: 0;
                }

                &:nth-child(4n) {
                    margin-right: 0;
                }
            }
        }

        .goods-item {
            display: block;
            width: 220px;
            padding: 20px 30px;
            text-align: center;
            transition: all .5s;

            &:hover {
                transform: translate3d(0, -3px, 0);
                box-shadow: 0 3px 8px rgb(0 0 0 / 20%);
            }

            img {
                width: 160px;
                height: 160px;
            }

            p {
                padding-top: 10px;
            }

            .name {
                font-size: 16px;
            }

            .desc {
                color: #999;
                height: 29px;
            }

            .price {
                color: $priceColor;
                font-size: 20px;
            }
        }
    }
}
</style>
```



### 封装GoodsItem组件

在本项目的很多个业务模块中都需要用到同样的商品展示模块，所以我们可以将其封装起来，方便复用

```vue
<script setup>
defineProps({
    good: {
        type: Object,
        default: () => {
        }
    }
})
</script>

<template>
    <RouterLink to="/" class="goods-item">
        <img v-img-lazy="good.picture" alt=""/>
        <p class="name ellipsis">{{ good.name }}</p>
        <p class="desc ellipsis">{{ good.desc }}</p>
        <p class="price">&yen;{{ good.price }}</p>
    </RouterLink>
</template>

<style scoped lang="scss">
.goods-item {
  display: block;
  width: 220px;
  padding: 20px 30px;
  text-align: center;
  transition: all .5s;

  &:hover {
    transform: translate3d(0, -3px, 0);
    box-shadow: 0 3px 8px rgb(0 0 0 / 20%);
  }

  img {
    width: 160px;
    height: 160px;
  }

  p {
    padding-top: 10px;
  }

  .name {
    font-size: 16px;
  }

  .desc {
    color: #999;
    height: 29px;
  }

  .price {
    color: $priceColor;
    font-size: 20px;
  }
}
</style>
```

